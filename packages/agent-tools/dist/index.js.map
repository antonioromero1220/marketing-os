{"version":3,"sources":["../src/kv.ts","../src/tasks.ts","../src/coordination.ts","../src/index.ts"],"sourcesContent":["/**\n * @growthub/agent-tools/kv\n * KV Lock Management and Coordination Utilities\n * \n * Professional KV lock patterns extracted from the AT-03 production system.\n * Provides distributed locking for agent coordination with TTL-based cleanup.\n */\n\nimport { z } from 'zod'\nimport type { ValidationResult } from '@growthub/compiler-core'\nimport { validateKVLock } from '@growthub/compiler-core'\n\n// KV Lock Metadata Schema\nexport const KVLockMetadataSchema = z.object({\n  lockedAt: z.string().datetime(),\n  lockId: z.string().optional(),\n  processId: z.string().optional(),\n  metadata: z.record(z.any()).optional(),\n  expiresAt: z.string().datetime().optional(),\n})\n\nexport type KVLockMetadata = z.infer<typeof KVLockMetadataSchema>\n\n// KV Store Interface\nexport interface KVStore {\n  get(key: string): Promise<any>\n  set(key: string, value: any, options?: { ttl?: number; condition?: 'nx' | 'xx' }): Promise<boolean>\n  delete(key: string): Promise<boolean>\n}\n\n// In-Memory KV Store Implementation\nexport class InMemoryKVStore implements KVStore {\n  private store = new Map<string, { value: any; expiresAt?: number }>()\n  \n  async get(key: string): Promise<any> {\n    const entry = this.store.get(key)\n    if (!entry) return null\n    \n    // Check if expired\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\n      this.store.delete(key)\n      return null\n    }\n    \n    return entry.value\n  }\n  \n  async set(key: string, value: any, options?: { ttl?: number; condition?: 'nx' | 'xx' }): Promise<boolean> {\n    const existing = this.store.get(key)\n    \n    // Handle conditional sets\n    if (options?.condition === 'nx' && existing && (!existing.expiresAt || Date.now() < existing.expiresAt)) {\n      return false // Key exists and not expired\n    }\n    if (options?.condition === 'xx' && (!existing || (existing.expiresAt && Date.now() > existing.expiresAt))) {\n      return false // Key doesn't exist or expired\n    }\n    \n    const entry: { value: any; expiresAt?: number } = { value }\n    if (options?.ttl) {\n      entry.expiresAt = Date.now() + (options.ttl * 1000)\n    }\n    \n    this.store.set(key, entry)\n    return true\n  }\n  \n  async delete(key: string): Promise<boolean> {\n    return this.store.delete(key)\n  }\n}\n\n// Lock Configuration\nexport interface KVLockConfig {\n  ttlSeconds?: number\n  metadata?: KVLockMetadata\n  keyPrefix?: string\n}\n\nexport interface AcquireLockOptions {\n  ttlSeconds?: number\n  metadata?: KVLockMetadata\n}\n\nexport interface KVLockResult {\n  success: boolean\n  activeLockMetadata?: KVLockMetadata\n  lockKey: string\n}\n\n// Default Configuration\nexport const DEFAULT_LOCK_TTL_SECONDS = 15 * 60 // 15 minutes\n\n/**\n * KV Lock Manager Class\n * Provides distributed locking with automatic TTL cleanup and validation\n */\nexport class KVLockManager {\n  private kv: KVStore\n  private defaultTTL: number\n  private keyPrefix: string\n\n  constructor(\n    kvStore?: KVStore, \n    options: { defaultTTL?: number; keyPrefix?: string } = {}\n  ) {\n    this.kv = kvStore || new InMemoryKVStore()\n    this.defaultTTL = options.defaultTTL || DEFAULT_LOCK_TTL_SECONDS\n    this.keyPrefix = options.keyPrefix || 'run'\n  }\n\n  /**\n   * Generate KV lock key following the singleton pattern\n   */\n  makeKvLockKey(userId: string, threadId: string): string {\n    return `${this.keyPrefix}:${userId}:${threadId}`\n  }\n\n  /**\n   * Try to acquire a KV lock for a user/thread\n   */\n  async acquireKvLock(\n    userId: string,\n    threadId: string,\n    options?: AcquireLockOptions\n  ): Promise<KVLockResult> {\n    const kvKey = this.makeKvLockKey(userId, threadId)\n    const ttl = options?.ttlSeconds ?? this.defaultTTL\n    \n    try {\n      // Validate input data\n      const validationResult = validateKVLock({\n        userId,\n        threadId,\n        lockKey: kvKey,\n        ttl: ttl * 1000, // Convert to ms for validation\n        metadata: {\n          runId: `${userId}-${threadId}`,\n          lockAcquired: Date.now(),\n          processId: process.pid?.toString(),\n          expiresAt: new Date(Date.now() + ttl * 1000).toISOString()\n        }\n      })\n\n      if (!validationResult.success) {\n        throw new Error(`KV lock validation failed: ${JSON.stringify(validationResult.errors)}`)\n      }\n\n      const lockMetadata: KVLockMetadata = options?.metadata ?? {\n        lockedAt: new Date().toISOString(),\n        lockId: `${userId}-${threadId}-${Date.now()}`,\n        processId: process.pid?.toString(),\n        expiresAt: new Date(Date.now() + ttl * 1000).toISOString(),\n      }\n      \n      const lockSet = await this.kv.set(kvKey, lockMetadata, {\n        ttl,\n        condition: 'nx', // Only set if not exists\n      })\n      \n      if (!lockSet) {\n        const activeMetadataRaw = await this.kv.get(kvKey)\n        const activeLockMetadata = activeMetadataRaw || { lockedAt: 'unknown' }\n        return { \n          success: false, \n          activeLockMetadata,\n          lockKey: kvKey \n        }\n      }\n      \n      return { \n        success: true,\n        lockKey: kvKey\n      }\n    } catch (error) {\n      console.error(`Error acquiring KV lock for key ${kvKey}`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Release the KV lock for a user/thread\n   */\n  async releaseKvLock(userId: string, threadId: string): Promise<boolean> {\n    const kvKey = this.makeKvLockKey(userId, threadId)\n    \n    try {\n      return await this.kv.delete(kvKey)\n    } catch (error) {\n      console.error(`Error releasing KV lock for key ${kvKey}`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Check the lock status by returning stored metadata or null if unlocked\n   */\n  async checkKvLock(\n    userId: string,\n    threadId: string\n  ): Promise<KVLockMetadata | null> {\n    const kvKey = this.makeKvLockKey(userId, threadId)\n    \n    try {\n      const data = await this.kv.get(kvKey)\n      if (!data) return null\n      \n      if (typeof data === 'string') {\n        try {\n          return JSON.parse(data)\n        } catch {\n          return { lockedAt: 'invalid data' } as KVLockMetadata\n        }\n      }\n      \n      return data as KVLockMetadata\n    } catch (error) {\n      console.error(`Error checking KV lock for key ${kvKey}`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Utility function to run code with automatic lock acquisition and release\n   */\n  async withKvLock<T>(\n    userId: string,\n    threadId: string,\n    operation: () => Promise<T>,\n    options?: AcquireLockOptions\n  ): Promise<T> {\n    const lockResult = await this.acquireKvLock(userId, threadId, options)\n    \n    if (!lockResult.success) {\n      throw new Error(`Failed to acquire lock for user ${userId}, thread ${threadId}. Active lock: ${JSON.stringify(lockResult.activeLockMetadata)}`)\n    }\n    \n    try {\n      return await operation()\n    } finally {\n      await this.releaseKvLock(userId, threadId)\n    }\n  }\n}\n\n// Singleton instance for backward compatibility\nexport const defaultKVLockManager = new KVLockManager()\n\n/**\n * Convenience functions using the default manager\n */\nexport const makeKvLockKey = (userId: string, threadId: string) => \n  defaultKVLockManager.makeKvLockKey(userId, threadId)\n\nexport const acquireKvLock = (userId: string, threadId: string, options?: AcquireLockOptions) => \n  defaultKVLockManager.acquireKvLock(userId, threadId, options)\n\nexport const releaseKvLock = (userId: string, threadId: string) => \n  defaultKVLockManager.releaseKvLock(userId, threadId)\n\nexport const checkKvLock = (userId: string, threadId: string) => \n  defaultKVLockManager.checkKvLock(userId, threadId)\n\nexport const withKvLock = <T>(\n  userId: string, \n  threadId: string, \n  operation: () => Promise<T>, \n  options?: AcquireLockOptions\n) => defaultKVLockManager.withKvLock(userId, threadId, operation, options)\n\n/**\n * Validate KV lock metadata using Zod\n */\nexport function validateKVLockMetadata(data: unknown): ValidationResult<KVLockMetadata> {\n  try {\n    const validatedData = KVLockMetadataSchema.parse(data)\n    return { success: true, data: validatedData }\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        errors: error.errors.map(err => ({\n          field: err.path.join('.'),\n          message: err.message,\n          code: err.code,\n          severity: 'error' as const\n        }))\n      }\n    }\n    return {\n      success: false,\n      errors: [{\n        field: 'metadata',\n        message: 'Unknown validation error',\n        code: 'UNKNOWN_ERROR',\n        severity: 'error'\n      }]\n    }\n  }\n} ","/**\n * @growthub/agent-tools/tasks\n * Agent Task Coordination and OpenAI Function Calling Abstractions\n * \n * Professional agent task patterns extracted from the AT-03 production system.\n * Provides simplified abstractions for OpenAI function calling and task coordination.\n */\n\nimport { z } from 'zod'\nimport type { CSI } from '@growthub/compiler-core'\n\n// Base schemas for all agent tasks\nexport const BaseAgentTaskRequestSchema = z.object({\n  threadId: z.string().uuid(),\n  userId: z.string().min(1),\n  agentType: z.enum(['CONTENT_GENERATION_AGENT', 'TEXT_ANALYSIS_AGENT']),\n  taskSequence: z.number().int().min(1),\n  previousCSI: z.object({\n    completedSteps: z.array(z.string()).default([]),\n    currentProgress: z.number().default(0),\n    totalSteps: z.number().default(4),\n    currentStep: z.string().default('pending')\n  }).optional(),\n})\n\nexport type BaseAgentTaskRequest = z.infer<typeof BaseAgentTaskRequestSchema>\n\n// Agent task function definition\nexport interface AgentTaskFunction {\n  name: string\n  description: string\n  parameters: {\n    type: \"object\"\n    properties: Record<string, any>\n    required: string[]\n  }\n}\n\n// Agent task execution result\nexport interface AgentTaskResult {\n  success: boolean\n  stepResult: {\n    step: string\n    [key: string]: any\n  }\n  updatedCSI: CSI\n  agentTaskId?: string\n  error?: {\n    message: string\n    code: string\n    details?: any\n  }\n}\n\n// Agent task configuration\nexport interface AgentTaskConfig {\n  taskName: string\n  taskType: 'analysis' | 'image_generation' | 'text_generation' | 'completion'\n  apiRoute?: string\n  toolName: string\n  systemPrompt: string\n  userPromptTemplate: (data: any) => string\n  functionDefinition: AgentTaskFunction\n  progressPercent: number\n  modelConfig?: {\n    model?: string\n    temperature?: number\n    maxTokens?: number\n    topP?: number\n  }\n}\n\n// OpenAI Client Interface\nexport interface OpenAIClient {\n  chat: {\n    completions: {\n      create(params: any): Promise<any>\n    }\n  }\n}\n\n/**\n * Agent Task Executor Class\n * Handles the complete lifecycle of agent tasks with OpenAI function calling\n */\nexport class AgentTaskExecutor {\n  private openaiClient: OpenAIClient\n  private defaultModel: string\n  private defaultTemperature: number\n\n  constructor(\n    openaiClient: OpenAIClient,\n    options: { \n      defaultModel?: string\n      defaultTemperature?: number \n    } = {}\n  ) {\n    this.openaiClient = openaiClient\n    this.defaultModel = options.defaultModel || 'gpt-4o-mini'\n    this.defaultTemperature = options.defaultTemperature || 0.3\n  }\n\n  /**\n   * Execute an agent task with OpenAI function calling\n   */\n  async executeAgentTask<T extends BaseAgentTaskRequest>(\n    request: T,\n    taskInput: Record<string, any>,\n    config: AgentTaskConfig\n  ): Promise<AgentTaskResult> {\n    try {\n      // Validate request\n      const validatedRequest = BaseAgentTaskRequestSchema.parse(request)\n\n      // Prepare OpenAI request\n      const modelConfig = config.modelConfig || {}\n      const response = await this.openaiClient.chat.completions.create({\n        model: modelConfig.model || this.defaultModel,\n        messages: [\n          {\n            role: \"system\",\n            content: config.systemPrompt\n          },\n          {\n            role: \"user\",\n            content: config.userPromptTemplate(taskInput)\n          }\n        ],\n        tools: [{ type: \"function\", function: config.functionDefinition }],\n        tool_choice: { type: \"function\", function: { name: config.functionDefinition.name } },\n        temperature: modelConfig.temperature ?? this.defaultTemperature,\n        ...(modelConfig.maxTokens && { max_tokens: modelConfig.maxTokens }),\n        ...(modelConfig.topP && { top_p: modelConfig.topP })\n      })\n\n      // Parse result\n      const toolCall = response.choices[0].message.tool_calls?.[0]\n      if (!toolCall) {\n        throw new Error('No function call returned from OpenAI')\n      }\n\n      const result = JSON.parse(toolCall.function.arguments || '{}')\n\n      // Update CSI\n      const previousCSI = validatedRequest.previousCSI || {\n        completedSteps: [],\n        currentProgress: 0,\n        totalSteps: 4,\n        currentStep: 'pending'\n      }\n\n      const updatedCSI: CSI = {\n        completedSteps: [...previousCSI.completedSteps, config.taskName],\n        currentProgress: config.progressPercent,\n        totalSteps: previousCSI.totalSteps,\n        currentStep: config.taskName,\n        metadata: {\n          lastUpdated: new Date().toISOString(),\n          taskName: config.taskName,\n          taskType: config.taskType\n        }\n      }\n\n      return {\n        success: true,\n        stepResult: { step: config.taskName, ...result },\n        updatedCSI\n      }\n\n    } catch (error) {\n      console.error(`[${config.taskName}] Failed:`, error)\n      \n      return {\n        success: false,\n        stepResult: { step: config.taskName },\n        updatedCSI: request.previousCSI || {\n          completedSteps: [],\n          currentProgress: 0,\n          totalSteps: 4,\n          currentStep: 'failed'\n        },\n        error: {\n          message: error instanceof Error ? error.message : 'Unknown error',\n          code: 'TASK_EXECUTION_FAILED',\n          details: error\n        }\n      }\n    }\n  }\n}\n\n/**\n * Predefined Agent Task Configurations\n * Common configurations for different agent task types\n */\nexport const AgentTaskConfigs = {\n  INTENT_ANALYSIS: {\n    taskName: 'intent_analysis',\n    taskType: 'analysis' as const,\n    apiRoute: '/api/v2/decomposition/intent-analysis',\n    toolName: 'o3_mini_intent_analyzer',\n    systemPrompt: 'Analyze user prompts for content generation tasks. Use causal reasoning to determine intent, asset count, and types.',\n    userPromptTemplate: (data: any) => \n      `Analyze: \"${data.prompt}\" for ${data.brandContext?.brand_name || 'brand'} (${data.brandContext?.referenceImages?.length || 0} ref images)`,\n    functionDefinition: {\n      name: \"analyze_intent\",\n      description: \"Analyzes user prompt for asset generation intent\",\n      parameters: {\n        type: \"object\" as const,\n        properties: {\n          analysis: { type: \"string\" },\n          conclusion: { type: \"string\" },\n          confidence: { type: \"number\" },\n          inferred_assets: { type: \"integer\" },\n          asset_types: { type: \"array\", items: { type: \"string\" } },\n          reasoning_steps: { type: \"array\", items: { type: \"string\" } }\n        },\n        required: [\"analysis\", \"conclusion\", \"confidence\", \"inferred_assets\"]\n      }\n    },\n    progressPercent: 25\n  },\n\n  BRAND_ANALYSIS: {\n    taskName: 'brand_analysis',\n    taskType: 'analysis' as const,\n    apiRoute: '/api/v2/decomposition/brand-analysis',\n    toolName: 'o3_mini_brand_analyzer',\n    systemPrompt: 'Analyze brand assets for content generation readiness. Assess completeness, consistency, and strength.',\n    userPromptTemplate: (data: any) => \n      `Analyze brand: ${data.brandContext?.brand_name || 'Unknown'}\nColors: ${data.brandContext?.colors ? JSON.stringify(data.brandContext.colors) : 'None'}\nMessaging: ${data.brandContext?.messaging || 'None'}\nReference Images: ${data.brandContext?.referenceImages?.length || 0}`,\n    functionDefinition: {\n      name: \"analyze_brand\",\n      description: \"Analyzes brand assets and context for content generation readiness\",\n      parameters: {\n        type: \"object\" as const,\n        properties: {\n          analysis: { type: \"string\" },\n          conclusion: { type: \"string\" },\n          confidence: { type: \"number\" },\n          brand_strength: { type: \"string\", enum: [\"weak\", \"moderate\", \"strong\", \"excellent\"] },\n          brand_consistency_score: { type: \"number\" },\n          recommendations: { type: \"array\", items: { type: \"string\" } }\n        },\n        required: [\"analysis\", \"conclusion\", \"confidence\", \"brand_strength\"]\n      }\n    },\n    progressPercent: 50\n  },\n\n  COMPLEXITY_ASSESSMENT: {\n    taskName: 'complexity_assessment',\n    taskType: 'analysis' as const,\n    apiRoute: '/api/v2/decomposition/complexity-assessment',\n    toolName: 'o3_mini_complexity_analyzer',\n    systemPrompt: 'Assess complexity for content generation tasks. Consider assets, brand strength, and execution requirements.',\n    userPromptTemplate: (data: any) => \n      `Assess complexity:\nPrompt: \"${data.prompt || ''}\"\nBrand: ${data.brandContext?.brand_name || 'Unknown'} (${data.brandStrength || 'Unknown'})\nAssets: ${data.inferredAssets || 1}\nReferences: ${data.brandContext?.referenceImages?.length || 0}`,\n    functionDefinition: {\n      name: \"assess_complexity\",\n      description: \"Assesses task complexity for content generation execution\",\n      parameters: {\n        type: \"object\" as const,\n        properties: {\n          analysis: { type: \"string\" },\n          conclusion: { type: \"string\" },\n          confidence: { type: \"number\" },\n          complexity_level: { type: \"string\", enum: [\"simple\", \"moderate\", \"complex\", \"expert\"] },\n          complexity_score: { type: \"number\" },\n          estimated_duration_ms: { type: \"integer\" },\n          resource_requirements: { type: \"array\", items: { type: \"string\" } },\n          optimization_suggestions: { type: \"array\", items: { type: \"string\" } }\n        },\n        required: [\"analysis\", \"conclusion\", \"confidence\", \"complexity_level\", \"complexity_score\"]\n      }\n    },\n    progressPercent: 75\n  }\n}\n\n/**\n * Task Builder - Fluent interface for building agent tasks\n */\nexport class AgentTaskBuilder {\n  private config: Partial<AgentTaskConfig> = {}\n\n  static create(taskName: string): AgentTaskBuilder {\n    return new AgentTaskBuilder().name(taskName)\n  }\n\n  name(taskName: string): AgentTaskBuilder {\n    this.config.taskName = taskName\n    return this\n  }\n\n  type(taskType: AgentTaskConfig['taskType']): AgentTaskBuilder {\n    this.config.taskType = taskType\n    return this\n  }\n\n  route(apiRoute: string): AgentTaskBuilder {\n    this.config.apiRoute = apiRoute\n    return this\n  }\n\n  tool(toolName: string): AgentTaskBuilder {\n    this.config.toolName = toolName\n    return this\n  }\n\n  systemPrompt(prompt: string): AgentTaskBuilder {\n    this.config.systemPrompt = prompt\n    return this\n  }\n\n  userPrompt(template: (data: any) => string): AgentTaskBuilder {\n    this.config.userPromptTemplate = template\n    return this\n  }\n\n  function(definition: AgentTaskFunction): AgentTaskBuilder {\n    this.config.functionDefinition = definition\n    return this\n  }\n\n  progress(percent: number): AgentTaskBuilder {\n    this.config.progressPercent = percent\n    return this\n  }\n\n  model(config: AgentTaskConfig['modelConfig']): AgentTaskBuilder {\n    this.config.modelConfig = config\n    return this\n  }\n\n  build(): AgentTaskConfig {\n    const required = [\n      'taskName', 'taskType', 'toolName', 'systemPrompt', \n      'userPromptTemplate', 'functionDefinition', 'progressPercent'\n    ]\n\n    for (const field of required) {\n      if (!this.config[field as keyof AgentTaskConfig]) {\n        throw new Error(`Missing required field: ${field}`)\n      }\n    }\n\n    return this.config as AgentTaskConfig\n  }\n}\n\n/**\n * Error handling utilities\n */\nexport function handleAgentTaskError(error: any, taskName: string) {\n  console.error(`[${taskName}] Failed:`, error)\n  \n  if (error instanceof z.ZodError) {\n    return {\n      success: false,\n      error: 'Invalid request data',\n      details: error.errors\n    }\n  }\n\n  return {\n    success: false,\n    error: `${taskName} failed`,\n    message: error instanceof Error ? error.message : 'Unknown error'\n  }\n}\n\n/**\n * Validate agent task request\n */\nexport function validateAgentTaskRequest(data: unknown): { success: boolean; data?: BaseAgentTaskRequest; errors?: any[] } {\n  try {\n    const validatedData = BaseAgentTaskRequestSchema.parse(data)\n    return { success: true, data: validatedData }\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return { success: false, errors: error.errors }\n    }\n    return { success: false, errors: [{ message: 'Unknown validation error' }] }\n  }\n}\n\n/**\n * Create task helpers using predefined configurations\n */\nexport const createTaskHelpers = (executor: AgentTaskExecutor) => ({\n  createIntentAnalysisTask: (request: BaseAgentTaskRequest & { prompt: string; brandContext: any }) => \n    executor.executeAgentTask(request, { prompt: request.prompt, brandContext: request.brandContext }, AgentTaskConfigs.INTENT_ANALYSIS),\n\n  createBrandAnalysisTask: (request: BaseAgentTaskRequest & { brandContext: any }) => \n    executor.executeAgentTask(request, { brandContext: request.brandContext }, AgentTaskConfigs.BRAND_ANALYSIS),\n\n  createComplexityAssessmentTask: (request: BaseAgentTaskRequest & { \n    prompt: string; \n    brandContext: any; \n    inferredAssets: number; \n    brandStrength: string \n  }) => \n    executor.executeAgentTask(request, { \n      prompt: request.prompt, \n      brandContext: request.brandContext, \n      inferredAssets: request.inferredAssets,\n      brandStrength: request.brandStrength \n    }, AgentTaskConfigs.COMPLEXITY_ASSESSMENT)\n}) ","/**\n * @growthub/agent-tools/coordination\n * Agent Coordination Utilities Combining KV Locks and Task Management\n * \n * High-level coordination patterns that combine KV locking with agent task execution\n * for distributed agent orchestration with race condition prevention.\n */\n\nimport { z } from 'zod'\nimport type { CSI } from '@growthub/compiler-core'\nimport type { KVLockManager, KVLockMetadata, AcquireLockOptions } from './kv'\nimport type { AgentTaskExecutor, AgentTaskConfig, BaseAgentTaskRequest, AgentTaskResult } from './tasks'\n\n// Coordination Request Schema\nexport const CoordinationRequestSchema = z.object({\n  threadId: z.string().uuid(),\n  userId: z.string().uuid(),\n  agentType: z.enum(['CONTENT_GENERATION_AGENT', 'TEXT_ANALYSIS_AGENT']),\n  operation: z.string().min(1),\n  lockOptions: z.object({\n    ttlSeconds: z.number().int().positive().optional(),\n    keyPrefix: z.string().optional()\n  }).optional(),\n  metadata: z.record(z.any()).optional()\n})\n\nexport type CoordinationRequest = z.infer<typeof CoordinationRequestSchema>\n\n// Coordination Result\nexport interface CoordinationResult<T = any> {\n  success: boolean\n  result?: T\n  error?: {\n    message: string\n    code: string\n    type: 'LOCK_ACQUISITION_FAILED' | 'TASK_EXECUTION_FAILED' | 'VALIDATION_FAILED'\n    details?: any\n  }\n  lockMetadata?: {\n    lockKey: string\n    lockAcquired: boolean\n    lockReleased: boolean\n    lockDuration?: number\n  }\n  executionMetadata?: {\n    startTime: string\n    endTime?: string\n    duration?: number\n    retryCount?: number\n  }\n}\n\n// Orchestration Step Configuration\nexport interface OrchestrationStepConfig {\n  stepId: string\n  taskConfig: AgentTaskConfig\n  lockKeyPrefix?: string\n  dependencies?: string[]\n  retryConfig?: {\n    maxRetries: number\n    backoffMs: number\n  }\n}\n\n/**\n * Agent Coordination Manager\n * Combines KV locking with agent task execution for distributed coordination\n */\nexport class AgentCoordinationManager {\n  private kvManager: KVLockManager\n  private taskExecutor: AgentTaskExecutor\n\n  constructor(kvManager: KVLockManager, taskExecutor: AgentTaskExecutor) {\n    this.kvManager = kvManager\n    this.taskExecutor = taskExecutor\n  }\n\n  /**\n   * Execute a single agent task with automatic lock coordination\n   */\n  async executeTaskWithLock<T extends BaseAgentTaskRequest>(\n    request: T,\n    taskInput: Record<string, any>,\n    taskConfig: AgentTaskConfig,\n    lockOptions?: AcquireLockOptions\n  ): Promise<CoordinationResult<AgentTaskResult>> {\n    const startTime = new Date().toISOString()\n    const lockKey = this.kvManager.makeKvLockKey(request.userId, request.threadId)\n    let lockAcquired = false\n    let lockReleased = false\n\n    try {\n      // Step 1: Acquire KV lock\n      const lockResult = await this.kvManager.acquireKvLock(\n        request.userId, \n        request.threadId, \n        lockOptions\n      )\n\n      if (!lockResult.success) {\n        return {\n          success: false,\n          error: {\n            message: `Failed to acquire lock for ${taskConfig.taskName}`,\n            code: 'LOCK_ACQUISITION_FAILED',\n            type: 'LOCK_ACQUISITION_FAILED',\n            details: lockResult.activeLockMetadata\n          },\n          lockMetadata: {\n            lockKey,\n            lockAcquired: false,\n            lockReleased: false\n          }\n        }\n      }\n\n      lockAcquired = true\n\n      // Step 2: Execute agent task\n      const taskResult = await this.taskExecutor.executeAgentTask(\n        request,\n        taskInput,\n        taskConfig\n      )\n\n      // Step 3: Release lock\n      lockReleased = await this.kvManager.releaseKvLock(request.userId, request.threadId)\n\n      const endTime = new Date().toISOString()\n\n      return {\n        success: taskResult.success,\n        result: taskResult,\n        error: taskResult.success ? undefined : {\n          message: taskResult.error?.message || 'Task execution failed',\n          code: taskResult.error?.code || 'TASK_EXECUTION_FAILED',\n          type: 'TASK_EXECUTION_FAILED',\n          details: taskResult.error?.details\n        },\n        lockMetadata: {\n          lockKey,\n          lockAcquired,\n          lockReleased,\n          lockDuration: new Date(endTime).getTime() - new Date(startTime).getTime()\n        },\n        executionMetadata: {\n          startTime,\n          endTime,\n          duration: new Date(endTime).getTime() - new Date(startTime).getTime()\n        }\n      }\n\n    } catch (error) {\n      // Ensure lock is released on error\n      if (lockAcquired && !lockReleased) {\n        try {\n          await this.kvManager.releaseKvLock(request.userId, request.threadId)\n          lockReleased = true\n        } catch (releaseError) {\n          console.error('Failed to release lock after error:', releaseError)\n        }\n      }\n\n      return {\n        success: false,\n        error: {\n          message: error instanceof Error ? error.message : 'Unknown coordination error',\n          code: 'COORDINATION_ERROR',\n          type: 'TASK_EXECUTION_FAILED',\n          details: error\n        },\n        lockMetadata: {\n          lockKey,\n          lockAcquired,\n          lockReleased\n        }\n      }\n    }\n  }\n\n  /**\n   * Execute multiple tasks in sequence with proper coordination\n   */\n  async executeTaskSequence<T extends BaseAgentTaskRequest>(\n    request: T,\n    steps: Array<{\n      taskInput: Record<string, any>\n      taskConfig: AgentTaskConfig\n      lockOptions?: AcquireLockOptions\n    }>\n  ): Promise<CoordinationResult<Array<AgentTaskResult>>> {\n    const results: AgentTaskResult[] = []\n    const errors: any[] = []\n    let currentCSI: CSI = request.previousCSI || {\n      completedSteps: [],\n      currentProgress: 0,\n      totalSteps: steps.length,\n      currentStep: 'pending'\n    }\n\n    for (let i = 0; i < steps.length; i++) {\n      const step = steps[i]\n      const stepRequest = {\n        ...request,\n        taskSequence: i + 1,\n        previousCSI: currentCSI\n      }\n\n      const result = await this.executeTaskWithLock(\n        stepRequest,\n        step.taskInput,\n        step.taskConfig,\n        step.lockOptions\n      )\n\n      if (result.success && result.result) {\n        results.push(result.result)\n        currentCSI = result.result.updatedCSI\n      } else {\n        errors.push(result.error)\n        break // Stop on first error\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      result: results,\n      error: errors.length > 0 ? errors[0] : undefined\n    }\n  }\n\n  /**\n   * Check if a coordination operation is already in progress\n   */\n  async isOperationInProgress(\n    userId: string,\n    threadId: string,\n    operationPrefix?: string\n  ): Promise<boolean> {\n    const lockKey = operationPrefix \n      ? `${operationPrefix}:${userId}:${threadId}`\n      : this.kvManager.makeKvLockKey(userId, threadId)\n    \n    try {\n      const lockMetadata = await this.kvManager.checkKvLock(userId, threadId)\n      return lockMetadata !== null\n    } catch (error) {\n      console.error('Error checking operation progress:', error)\n      return false\n    }\n  }\n\n  /**\n   * Cancel an ongoing operation by releasing its lock\n   */\n  async cancelOperation(userId: string, threadId: string): Promise<boolean> {\n    try {\n      return await this.kvManager.releaseKvLock(userId, threadId)\n    } catch (error) {\n      console.error('Error cancelling operation:', error)\n      return false\n    }\n  }\n}\n\n/**\n * Orchestration Manager\n * High-level orchestration patterns with dependency management\n */\nexport class OrchestrationManager extends AgentCoordinationManager {\n  \n  /**\n   * Execute orchestration steps with dependency resolution\n   */\n  async executeOrchestration<T extends BaseAgentTaskRequest>(\n    request: T,\n    steps: OrchestrationStepConfig[],\n    orchestrationData: Record<string, any>\n  ): Promise<CoordinationResult<Record<string, AgentTaskResult>>> {\n    const results: Record<string, AgentTaskResult> = {}\n    const completedSteps = new Set<string>()\n    const pendingSteps = new Set(steps.map(s => s.stepId))\n\n    while (pendingSteps.size > 0) {\n      // Find steps with satisfied dependencies\n      const executableSteps = steps.filter(step => \n        pendingSteps.has(step.stepId) &&\n        (!step.dependencies || step.dependencies.every(dep => completedSteps.has(dep)))\n      )\n\n      if (executableSteps.length === 0) {\n        // No executable steps - possible circular dependency\n        return {\n          success: false,\n          error: {\n            message: 'No executable steps found - possible circular dependency',\n            code: 'ORCHESTRATION_DEADLOCK',\n            type: 'TASK_EXECUTION_FAILED',\n            details: { pendingSteps: Array.from(pendingSteps), completedSteps: Array.from(completedSteps) }\n          }\n        }\n      }\n\n      // Execute all executable steps\n      for (const step of executableSteps) {\n        const stepData = {\n          ...orchestrationData,\n          // Include results from dependency steps\n          ...(step.dependencies?.reduce((acc, depId) => {\n            acc[depId] = results[depId]\n            return acc\n          }, {} as Record<string, AgentTaskResult>) || {})\n        }\n\n        const result = await this.executeTaskWithLock(\n          request,\n          stepData,\n          step.taskConfig,\n          { \n            ttlSeconds: 900, // 15 minutes for orchestration steps\n            metadata: {\n              lockedAt: new Date().toISOString(),\n              lockId: `orchestration-${step.stepId}-${Date.now()}`,\n              processId: process.pid?.toString()\n            }\n          }\n        )\n\n        if (result.success && result.result) {\n          results[step.stepId] = result.result\n          completedSteps.add(step.stepId)\n          pendingSteps.delete(step.stepId)\n        } else {\n          return {\n            success: false,\n            result: results,\n            error: {\n              message: `Orchestration step '${step.stepId}' failed`,\n              code: 'ORCHESTRATION_STEP_FAILED',\n              type: 'TASK_EXECUTION_FAILED',\n              details: result.error\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      success: true,\n      result: results\n    }\n  }\n}\n\n/**\n * Validate coordination request\n */\nexport function validateCoordinationRequest(data: unknown): { success: boolean; data?: CoordinationRequest; errors?: any[] } {\n  try {\n    const validatedData = CoordinationRequestSchema.parse(data)\n    return { success: true, data: validatedData }\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return { success: false, errors: error.errors }\n    }\n    return { success: false, errors: [{ message: 'Unknown validation error' }] }\n  }\n}\n\n/**\n * Create coordination result\n */\nexport function createCoordinationResult<T>(\n  success: boolean,\n  result?: T,\n  error?: CoordinationResult['error']\n): CoordinationResult<T> {\n  return {\n    success,\n    result,\n    error,\n    executionMetadata: {\n      startTime: new Date().toISOString(),\n      duration: 0\n    }\n  }\n}\n\n/**\n * Coordination utilities\n */\nexport const CoordinationUtils = {\n  /**\n   * Generate unique operation ID\n   */\n  generateOperationId: (userId: string, threadId: string, operation: string): string => {\n    return `${operation}:${userId.slice(0, 8)}:${threadId.slice(0, 8)}:${Date.now()}`\n  },\n\n  /**\n   * Create lock key for specific operation\n   */\n  createOperationLockKey: (operation: string, userId: string, threadId: string): string => {\n    return `${operation}:${userId}:${threadId}`\n  },\n\n  /**\n   * Check if error is retryable\n   */\n  isRetryableError: (error: CoordinationResult['error']): boolean => {\n    return error?.type === 'LOCK_ACQUISITION_FAILED' || \n           error?.code === 'NETWORK_ERROR' ||\n           error?.code === 'TIMEOUT_ERROR'\n  }\n} ","/**\n * @growthub/agent-tools\n * Agent coordination utilities and KV lock management for Growthub Marketing OS\n * \n * This package provides professional agent coordination patterns extracted from\n * the AT-03 production system, including KV locks, task management, and orchestration.\n */\n\n// Re-export all KV utilities\nexport * from './kv'\nexport type {\n  KVLockMetadata,\n  KVStore,\n  KVLockConfig,\n  AcquireLockOptions,\n  KVLockResult\n} from './kv'\n\n// Re-export all task utilities  \nexport * from './tasks'\nexport type {\n  BaseAgentTaskRequest,\n  AgentTaskFunction,\n  AgentTaskResult,\n  AgentTaskConfig,\n  OpenAIClient\n} from './tasks'\n\n// Re-export all coordination utilities\nexport * from './coordination'\nexport type {\n  CoordinationRequest,\n  CoordinationResult,\n  OrchestrationStepConfig\n} from './coordination'\n\n// Package metadata\nexport const PACKAGE_INFO = {\n  name: '@growthub/agent-tools',\n  version: '1.0.0',\n  description: 'Agent coordination utilities and KV lock management for Growthub Marketing OS',\n  patterns: [\n    'KV Lock Management',\n    'Agent Task Coordination', \n    'OpenAI Function Calling Abstractions',\n    'Distributed Orchestration',\n    'Race Condition Prevention'\n  ],\n  compliance: 'AT-03 PROD STABLE'\n} as const "],"mappings":"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","names":["z","z"]}