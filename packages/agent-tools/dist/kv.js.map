{"version":3,"sources":["../src/kv.ts"],"sourcesContent":["/**\n * @growthub/agent-tools/kv\n * KV Lock Management and Coordination Utilities\n * \n * Professional KV lock patterns extracted from the AT-03 production system.\n * Provides distributed locking for agent coordination with TTL-based cleanup.\n */\n\nimport { z } from 'zod'\nimport type { ValidationResult } from '@growthub/compiler-core'\nimport { validateKVLock } from '@growthub/compiler-core'\n\n// KV Lock Metadata Schema\nexport const KVLockMetadataSchema = z.object({\n  lockedAt: z.string().datetime(),\n  lockId: z.string().optional(),\n  processId: z.string().optional(),\n  metadata: z.record(z.any()).optional(),\n  expiresAt: z.string().datetime().optional(),\n})\n\nexport type KVLockMetadata = z.infer<typeof KVLockMetadataSchema>\n\n// KV Store Interface\nexport interface KVStore {\n  get(key: string): Promise<any>\n  set(key: string, value: any, options?: { ttl?: number; condition?: 'nx' | 'xx' }): Promise<boolean>\n  delete(key: string): Promise<boolean>\n}\n\n// In-Memory KV Store Implementation\nexport class InMemoryKVStore implements KVStore {\n  private store = new Map<string, { value: any; expiresAt?: number }>()\n  \n  async get(key: string): Promise<any> {\n    const entry = this.store.get(key)\n    if (!entry) return null\n    \n    // Check if expired\n    if (entry.expiresAt && Date.now() > entry.expiresAt) {\n      this.store.delete(key)\n      return null\n    }\n    \n    return entry.value\n  }\n  \n  async set(key: string, value: any, options?: { ttl?: number; condition?: 'nx' | 'xx' }): Promise<boolean> {\n    const existing = this.store.get(key)\n    \n    // Handle conditional sets\n    if (options?.condition === 'nx' && existing && (!existing.expiresAt || Date.now() < existing.expiresAt)) {\n      return false // Key exists and not expired\n    }\n    if (options?.condition === 'xx' && (!existing || (existing.expiresAt && Date.now() > existing.expiresAt))) {\n      return false // Key doesn't exist or expired\n    }\n    \n    const entry: { value: any; expiresAt?: number } = { value }\n    if (options?.ttl) {\n      entry.expiresAt = Date.now() + (options.ttl * 1000)\n    }\n    \n    this.store.set(key, entry)\n    return true\n  }\n  \n  async delete(key: string): Promise<boolean> {\n    return this.store.delete(key)\n  }\n}\n\n// Lock Configuration\nexport interface KVLockConfig {\n  ttlSeconds?: number\n  metadata?: KVLockMetadata\n  keyPrefix?: string\n}\n\nexport interface AcquireLockOptions {\n  ttlSeconds?: number\n  metadata?: KVLockMetadata\n}\n\nexport interface KVLockResult {\n  success: boolean\n  activeLockMetadata?: KVLockMetadata\n  lockKey: string\n}\n\n// Default Configuration\nexport const DEFAULT_LOCK_TTL_SECONDS = 15 * 60 // 15 minutes\n\n/**\n * KV Lock Manager Class\n * Provides distributed locking with automatic TTL cleanup and validation\n */\nexport class KVLockManager {\n  private kv: KVStore\n  private defaultTTL: number\n  private keyPrefix: string\n\n  constructor(\n    kvStore?: KVStore, \n    options: { defaultTTL?: number; keyPrefix?: string } = {}\n  ) {\n    this.kv = kvStore || new InMemoryKVStore()\n    this.defaultTTL = options.defaultTTL || DEFAULT_LOCK_TTL_SECONDS\n    this.keyPrefix = options.keyPrefix || 'run'\n  }\n\n  /**\n   * Generate KV lock key following the singleton pattern\n   */\n  makeKvLockKey(userId: string, threadId: string): string {\n    return `${this.keyPrefix}:${userId}:${threadId}`\n  }\n\n  /**\n   * Try to acquire a KV lock for a user/thread\n   */\n  async acquireKvLock(\n    userId: string,\n    threadId: string,\n    options?: AcquireLockOptions\n  ): Promise<KVLockResult> {\n    const kvKey = this.makeKvLockKey(userId, threadId)\n    const ttl = options?.ttlSeconds ?? this.defaultTTL\n    \n    try {\n      // Validate input data\n      const validationResult = validateKVLock({\n        userId,\n        threadId,\n        lockKey: kvKey,\n        ttl: ttl * 1000, // Convert to ms for validation\n        metadata: {\n          runId: `${userId}-${threadId}`,\n          lockAcquired: Date.now(),\n          processId: process.pid?.toString(),\n          expiresAt: new Date(Date.now() + ttl * 1000).toISOString()\n        }\n      })\n\n      if (!validationResult.success) {\n        throw new Error(`KV lock validation failed: ${JSON.stringify(validationResult.errors)}`)\n      }\n\n      const lockMetadata: KVLockMetadata = options?.metadata ?? {\n        lockedAt: new Date().toISOString(),\n        lockId: `${userId}-${threadId}-${Date.now()}`,\n        processId: process.pid?.toString(),\n        expiresAt: new Date(Date.now() + ttl * 1000).toISOString(),\n      }\n      \n      const lockSet = await this.kv.set(kvKey, lockMetadata, {\n        ttl,\n        condition: 'nx', // Only set if not exists\n      })\n      \n      if (!lockSet) {\n        const activeMetadataRaw = await this.kv.get(kvKey)\n        const activeLockMetadata = activeMetadataRaw || { lockedAt: 'unknown' }\n        return { \n          success: false, \n          activeLockMetadata,\n          lockKey: kvKey \n        }\n      }\n      \n      return { \n        success: true,\n        lockKey: kvKey\n      }\n    } catch (error) {\n      console.error(`Error acquiring KV lock for key ${kvKey}`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Release the KV lock for a user/thread\n   */\n  async releaseKvLock(userId: string, threadId: string): Promise<boolean> {\n    const kvKey = this.makeKvLockKey(userId, threadId)\n    \n    try {\n      return await this.kv.delete(kvKey)\n    } catch (error) {\n      console.error(`Error releasing KV lock for key ${kvKey}`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Check the lock status by returning stored metadata or null if unlocked\n   */\n  async checkKvLock(\n    userId: string,\n    threadId: string\n  ): Promise<KVLockMetadata | null> {\n    const kvKey = this.makeKvLockKey(userId, threadId)\n    \n    try {\n      const data = await this.kv.get(kvKey)\n      if (!data) return null\n      \n      if (typeof data === 'string') {\n        try {\n          return JSON.parse(data)\n        } catch {\n          return { lockedAt: 'invalid data' } as KVLockMetadata\n        }\n      }\n      \n      return data as KVLockMetadata\n    } catch (error) {\n      console.error(`Error checking KV lock for key ${kvKey}`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Utility function to run code with automatic lock acquisition and release\n   */\n  async withKvLock<T>(\n    userId: string,\n    threadId: string,\n    operation: () => Promise<T>,\n    options?: AcquireLockOptions\n  ): Promise<T> {\n    const lockResult = await this.acquireKvLock(userId, threadId, options)\n    \n    if (!lockResult.success) {\n      throw new Error(`Failed to acquire lock for user ${userId}, thread ${threadId}. Active lock: ${JSON.stringify(lockResult.activeLockMetadata)}`)\n    }\n    \n    try {\n      return await operation()\n    } finally {\n      await this.releaseKvLock(userId, threadId)\n    }\n  }\n}\n\n// Singleton instance for backward compatibility\nexport const defaultKVLockManager = new KVLockManager()\n\n/**\n * Convenience functions using the default manager\n */\nexport const makeKvLockKey = (userId: string, threadId: string) => \n  defaultKVLockManager.makeKvLockKey(userId, threadId)\n\nexport const acquireKvLock = (userId: string, threadId: string, options?: AcquireLockOptions) => \n  defaultKVLockManager.acquireKvLock(userId, threadId, options)\n\nexport const releaseKvLock = (userId: string, threadId: string) => \n  defaultKVLockManager.releaseKvLock(userId, threadId)\n\nexport const checkKvLock = (userId: string, threadId: string) => \n  defaultKVLockManager.checkKvLock(userId, threadId)\n\nexport const withKvLock = <T>(\n  userId: string, \n  threadId: string, \n  operation: () => Promise<T>, \n  options?: AcquireLockOptions\n) => defaultKVLockManager.withKvLock(userId, threadId, operation, options)\n\n/**\n * Validate KV lock metadata using Zod\n */\nexport function validateKVLockMetadata(data: unknown): ValidationResult<KVLockMetadata> {\n  try {\n    const validatedData = KVLockMetadataSchema.parse(data)\n    return { success: true, data: validatedData }\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        errors: error.errors.map(err => ({\n          field: err.path.join('.'),\n          message: err.message,\n          code: err.code,\n          severity: 'error' as const\n        }))\n      }\n    }\n    return {\n      success: false,\n      errors: [{\n        field: 'metadata',\n        message: 'Unknown validation error',\n        code: 'UNKNOWN_ERROR',\n        severity: 'error'\n      }]\n    }\n  }\n} "],"mappings":"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","names":[]}