{"version":3,"sources":["../src/coordination.ts"],"sourcesContent":["/**\n * @growthub/agent-tools/coordination\n * Agent Coordination Utilities Combining KV Locks and Task Management\n * \n * High-level coordination patterns that combine KV locking with agent task execution\n * for distributed agent orchestration with race condition prevention.\n */\n\nimport { z } from 'zod'\nimport type { CSI } from '@growthub/compiler-core'\nimport type { KVLockManager, KVLockMetadata, AcquireLockOptions } from './kv'\nimport type { AgentTaskExecutor, AgentTaskConfig, BaseAgentTaskRequest, AgentTaskResult } from './tasks'\n\n// Coordination Request Schema\nexport const CoordinationRequestSchema = z.object({\n  threadId: z.string().uuid(),\n  userId: z.string().uuid(),\n  agentType: z.enum(['CONTENT_GENERATION_AGENT', 'TEXT_ANALYSIS_AGENT']),\n  operation: z.string().min(1),\n  lockOptions: z.object({\n    ttlSeconds: z.number().int().positive().optional(),\n    keyPrefix: z.string().optional()\n  }).optional(),\n  metadata: z.record(z.any()).optional()\n})\n\nexport type CoordinationRequest = z.infer<typeof CoordinationRequestSchema>\n\n// Coordination Result\nexport interface CoordinationResult<T = any> {\n  success: boolean\n  result?: T\n  error?: {\n    message: string\n    code: string\n    type: 'LOCK_ACQUISITION_FAILED' | 'TASK_EXECUTION_FAILED' | 'VALIDATION_FAILED'\n    details?: any\n  }\n  lockMetadata?: {\n    lockKey: string\n    lockAcquired: boolean\n    lockReleased: boolean\n    lockDuration?: number\n  }\n  executionMetadata?: {\n    startTime: string\n    endTime?: string\n    duration?: number\n    retryCount?: number\n  }\n}\n\n// Orchestration Step Configuration\nexport interface OrchestrationStepConfig {\n  stepId: string\n  taskConfig: AgentTaskConfig\n  lockKeyPrefix?: string\n  dependencies?: string[]\n  retryConfig?: {\n    maxRetries: number\n    backoffMs: number\n  }\n}\n\n/**\n * Agent Coordination Manager\n * Combines KV locking with agent task execution for distributed coordination\n */\nexport class AgentCoordinationManager {\n  private kvManager: KVLockManager\n  private taskExecutor: AgentTaskExecutor\n\n  constructor(kvManager: KVLockManager, taskExecutor: AgentTaskExecutor) {\n    this.kvManager = kvManager\n    this.taskExecutor = taskExecutor\n  }\n\n  /**\n   * Execute a single agent task with automatic lock coordination\n   */\n  async executeTaskWithLock<T extends BaseAgentTaskRequest>(\n    request: T,\n    taskInput: Record<string, any>,\n    taskConfig: AgentTaskConfig,\n    lockOptions?: AcquireLockOptions\n  ): Promise<CoordinationResult<AgentTaskResult>> {\n    const startTime = new Date().toISOString()\n    const lockKey = this.kvManager.makeKvLockKey(request.userId, request.threadId)\n    let lockAcquired = false\n    let lockReleased = false\n\n    try {\n      // Step 1: Acquire KV lock\n      const lockResult = await this.kvManager.acquireKvLock(\n        request.userId, \n        request.threadId, \n        lockOptions\n      )\n\n      if (!lockResult.success) {\n        return {\n          success: false,\n          error: {\n            message: `Failed to acquire lock for ${taskConfig.taskName}`,\n            code: 'LOCK_ACQUISITION_FAILED',\n            type: 'LOCK_ACQUISITION_FAILED',\n            details: lockResult.activeLockMetadata\n          },\n          lockMetadata: {\n            lockKey,\n            lockAcquired: false,\n            lockReleased: false\n          }\n        }\n      }\n\n      lockAcquired = true\n\n      // Step 2: Execute agent task\n      const taskResult = await this.taskExecutor.executeAgentTask(\n        request,\n        taskInput,\n        taskConfig\n      )\n\n      // Step 3: Release lock\n      lockReleased = await this.kvManager.releaseKvLock(request.userId, request.threadId)\n\n      const endTime = new Date().toISOString()\n\n      return {\n        success: taskResult.success,\n        result: taskResult,\n        error: taskResult.success ? undefined : {\n          message: taskResult.error?.message || 'Task execution failed',\n          code: taskResult.error?.code || 'TASK_EXECUTION_FAILED',\n          type: 'TASK_EXECUTION_FAILED',\n          details: taskResult.error?.details\n        },\n        lockMetadata: {\n          lockKey,\n          lockAcquired,\n          lockReleased,\n          lockDuration: new Date(endTime).getTime() - new Date(startTime).getTime()\n        },\n        executionMetadata: {\n          startTime,\n          endTime,\n          duration: new Date(endTime).getTime() - new Date(startTime).getTime()\n        }\n      }\n\n    } catch (error) {\n      // Ensure lock is released on error\n      if (lockAcquired && !lockReleased) {\n        try {\n          await this.kvManager.releaseKvLock(request.userId, request.threadId)\n          lockReleased = true\n        } catch (releaseError) {\n          console.error('Failed to release lock after error:', releaseError)\n        }\n      }\n\n      return {\n        success: false,\n        error: {\n          message: error instanceof Error ? error.message : 'Unknown coordination error',\n          code: 'COORDINATION_ERROR',\n          type: 'TASK_EXECUTION_FAILED',\n          details: error\n        },\n        lockMetadata: {\n          lockKey,\n          lockAcquired,\n          lockReleased\n        }\n      }\n    }\n  }\n\n  /**\n   * Execute multiple tasks in sequence with proper coordination\n   */\n  async executeTaskSequence<T extends BaseAgentTaskRequest>(\n    request: T,\n    steps: Array<{\n      taskInput: Record<string, any>\n      taskConfig: AgentTaskConfig\n      lockOptions?: AcquireLockOptions\n    }>\n  ): Promise<CoordinationResult<Array<AgentTaskResult>>> {\n    const results: AgentTaskResult[] = []\n    const errors: any[] = []\n    let currentCSI: CSI = request.previousCSI || {\n      completedSteps: [],\n      currentProgress: 0,\n      totalSteps: steps.length,\n      currentStep: 'pending'\n    }\n\n    for (let i = 0; i < steps.length; i++) {\n      const step = steps[i]\n      const stepRequest = {\n        ...request,\n        taskSequence: i + 1,\n        previousCSI: currentCSI\n      }\n\n      const result = await this.executeTaskWithLock(\n        stepRequest,\n        step.taskInput,\n        step.taskConfig,\n        step.lockOptions\n      )\n\n      if (result.success && result.result) {\n        results.push(result.result)\n        currentCSI = result.result.updatedCSI\n      } else {\n        errors.push(result.error)\n        break // Stop on first error\n      }\n    }\n\n    return {\n      success: errors.length === 0,\n      result: results,\n      error: errors.length > 0 ? errors[0] : undefined\n    }\n  }\n\n  /**\n   * Check if a coordination operation is already in progress\n   */\n  async isOperationInProgress(\n    userId: string,\n    threadId: string,\n    operationPrefix?: string\n  ): Promise<boolean> {\n    const lockKey = operationPrefix \n      ? `${operationPrefix}:${userId}:${threadId}`\n      : this.kvManager.makeKvLockKey(userId, threadId)\n    \n    try {\n      const lockMetadata = await this.kvManager.checkKvLock(userId, threadId)\n      return lockMetadata !== null\n    } catch (error) {\n      console.error('Error checking operation progress:', error)\n      return false\n    }\n  }\n\n  /**\n   * Cancel an ongoing operation by releasing its lock\n   */\n  async cancelOperation(userId: string, threadId: string): Promise<boolean> {\n    try {\n      return await this.kvManager.releaseKvLock(userId, threadId)\n    } catch (error) {\n      console.error('Error cancelling operation:', error)\n      return false\n    }\n  }\n}\n\n/**\n * Orchestration Manager\n * High-level orchestration patterns with dependency management\n */\nexport class OrchestrationManager extends AgentCoordinationManager {\n  \n  /**\n   * Execute orchestration steps with dependency resolution\n   */\n  async executeOrchestration<T extends BaseAgentTaskRequest>(\n    request: T,\n    steps: OrchestrationStepConfig[],\n    orchestrationData: Record<string, any>\n  ): Promise<CoordinationResult<Record<string, AgentTaskResult>>> {\n    const results: Record<string, AgentTaskResult> = {}\n    const completedSteps = new Set<string>()\n    const pendingSteps = new Set(steps.map(s => s.stepId))\n\n    while (pendingSteps.size > 0) {\n      // Find steps with satisfied dependencies\n      const executableSteps = steps.filter(step => \n        pendingSteps.has(step.stepId) &&\n        (!step.dependencies || step.dependencies.every(dep => completedSteps.has(dep)))\n      )\n\n      if (executableSteps.length === 0) {\n        // No executable steps - possible circular dependency\n        return {\n          success: false,\n          error: {\n            message: 'No executable steps found - possible circular dependency',\n            code: 'ORCHESTRATION_DEADLOCK',\n            type: 'TASK_EXECUTION_FAILED',\n            details: { pendingSteps: Array.from(pendingSteps), completedSteps: Array.from(completedSteps) }\n          }\n        }\n      }\n\n      // Execute all executable steps\n      for (const step of executableSteps) {\n        const stepData = {\n          ...orchestrationData,\n          // Include results from dependency steps\n          ...(step.dependencies?.reduce((acc, depId) => {\n            acc[depId] = results[depId]\n            return acc\n          }, {} as Record<string, AgentTaskResult>) || {})\n        }\n\n        const result = await this.executeTaskWithLock(\n          request,\n          stepData,\n          step.taskConfig,\n          { \n            ttlSeconds: 900, // 15 minutes for orchestration steps\n            metadata: {\n              lockedAt: new Date().toISOString(),\n              lockId: `orchestration-${step.stepId}-${Date.now()}`,\n              processId: process.pid?.toString()\n            }\n          }\n        )\n\n        if (result.success && result.result) {\n          results[step.stepId] = result.result\n          completedSteps.add(step.stepId)\n          pendingSteps.delete(step.stepId)\n        } else {\n          return {\n            success: false,\n            result: results,\n            error: {\n              message: `Orchestration step '${step.stepId}' failed`,\n              code: 'ORCHESTRATION_STEP_FAILED',\n              type: 'TASK_EXECUTION_FAILED',\n              details: result.error\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      success: true,\n      result: results\n    }\n  }\n}\n\n/**\n * Validate coordination request\n */\nexport function validateCoordinationRequest(data: unknown): { success: boolean; data?: CoordinationRequest; errors?: any[] } {\n  try {\n    const validatedData = CoordinationRequestSchema.parse(data)\n    return { success: true, data: validatedData }\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return { success: false, errors: error.errors }\n    }\n    return { success: false, errors: [{ message: 'Unknown validation error' }] }\n  }\n}\n\n/**\n * Create coordination result\n */\nexport function createCoordinationResult<T>(\n  success: boolean,\n  result?: T,\n  error?: CoordinationResult['error']\n): CoordinationResult<T> {\n  return {\n    success,\n    result,\n    error,\n    executionMetadata: {\n      startTime: new Date().toISOString(),\n      duration: 0\n    }\n  }\n}\n\n/**\n * Coordination utilities\n */\nexport const CoordinationUtils = {\n  /**\n   * Generate unique operation ID\n   */\n  generateOperationId: (userId: string, threadId: string, operation: string): string => {\n    return `${operation}:${userId.slice(0, 8)}:${threadId.slice(0, 8)}:${Date.now()}`\n  },\n\n  /**\n   * Create lock key for specific operation\n   */\n  createOperationLockKey: (operation: string, userId: string, threadId: string): string => {\n    return `${operation}:${userId}:${threadId}`\n  },\n\n  /**\n   * Check if error is retryable\n   */\n  isRetryableError: (error: CoordinationResult['error']): boolean => {\n    return error?.type === 'LOCK_ACQUISITION_FAILED' || \n           error?.code === 'NETWORK_ERROR' ||\n           error?.code === 'TIMEOUT_ERROR'\n  }\n} "],"mappings":"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","names":[]}