{"version":3,"sources":["../src/decomposition.ts"],"sourcesContent":["/**\n * @growthub/compiler-core/decomposition\n * Core decomposition engine patterns and utilities\n */\n\nimport { z } from 'zod'\nimport type { BrandKitSchema } from '@growthub/schemas'\n\n// 2025 Real-Time CSI Schema for Decomposition Events\nexport const DecompositionEventSchema = z.object({\n  threadId: z.string().uuid(),\n  userId: z.string().min(1),\n  agentType: z.enum(['CONTENT_GENERATION_AGENT', 'TEXT_ANALYSIS_AGENT']),\n  prompt: z.string().min(1),\n  context: z.object({\n    brandKit: z.object({\n      id: z.string(),\n      brand_name: z.string(),\n      colors: z.object({\n        primary: z.string().optional(),\n        secondary: z.string().optional(),\n        accent: z.string().optional(),\n        neutral: z.string().optional(),\n      }).optional(),\n      messaging: z.string().optional(),\n    }),\n    referenceImages: z.array(z.object({\n      url: z.string(),\n      type: z.string(),\n      description: z.string()\n    })).default([]),\n  }),\n})\n\nexport type DecompositionEvent = z.infer<typeof DecompositionEventSchema>\n\n// OpenAI Structured Output Schema for Decomposition Validation\nexport const decompositionStructuredOutput = {\n  type: \"json_schema\" as const,\n  json_schema: {\n    name: \"decomposition_event\",\n    strict: true,\n    schema: {\n      type: \"object\",\n      properties: {\n        threadId: { type: \"string\", format: \"uuid\" },\n        userId: { type: \"string\", minLength: 1 },\n        agentType: { \n          type: \"string\", \n          enum: [\"CONTENT_GENERATION_AGENT\", \"TEXT_ANALYSIS_AGENT\"] \n        },\n        prompt: { type: \"string\", minLength: 1 },\n        context: {\n          type: \"object\",\n          properties: {\n            brandKit: {\n              type: \"object\",\n              properties: {\n                id: { type: \"string\" },\n                brand_name: { type: \"string\" },\n                colors: {\n                  type: \"object\",\n                  properties: {\n                    primary: { type: \"string\" },\n                    secondary: { type: \"string\" },\n                    accent: { type: \"string\" },\n                    neutral: { type: \"string\" }\n                  },\n                  required: [\"primary\", \"secondary\", \"accent\", \"neutral\"],\n                  additionalProperties: false\n                },\n                messaging: { type: \"string\" }\n              },\n              required: [\"id\", \"brand_name\", \"colors\", \"messaging\"],\n              additionalProperties: false\n            },\n            referenceImages: {\n              type: \"array\",\n              items: {\n                type: \"object\",\n                properties: {\n                  url: { type: \"string\" },\n                  type: { type: \"string\" },\n                  description: { type: \"string\" }\n                },\n                required: [\"url\", \"type\", \"description\"],\n                additionalProperties: false\n              }\n            }\n          },\n          required: [\"brandKit\", \"referenceImages\"],\n          additionalProperties: false\n        }\n      },\n      required: [\"threadId\", \"userId\", \"agentType\", \"prompt\", \"context\"],\n      additionalProperties: false\n    }\n  }\n}\n\n// Decomposition Result Types\nexport interface DecompositionResult {\n  threadId: string\n  userId: string\n  agentType: 'CONTENT_GENERATION_AGENT' | 'TEXT_ANALYSIS_AGENT'\n  steps: DecompositionStep[]\n  metadata: {\n    startedAt: string\n    completedAt?: string\n    duration?: number\n    status: 'pending' | 'running' | 'completed' | 'failed'\n  }\n}\n\nexport interface DecompositionStep {\n  stepName: string\n  stepType: 'analysis' | 'planning' | 'coordination' | 'execution'\n  status: 'pending' | 'running' | 'completed' | 'failed'\n  result?: any\n  metadata?: Record<string, any>\n  timestamp: string\n}\n\n// Brand Context Transformer\nexport interface BrandContext {\n  brand_name: string\n  colors: string[]\n  messaging: string | null\n  referenceImages: Array<{\n    url: string\n    type: string\n    description: string\n  }>\n}\n\n/**\n * Transform context from DecompositionEvent to BrandContext format\n */\nexport function transformBrandContext(context: DecompositionEvent['context']): BrandContext {\n  return {\n    brand_name: context.brandKit.brand_name,\n    colors: context.brandKit.colors \n      ? Object.values(context.brandKit.colors).filter(Boolean) as string[]\n      : [],\n    messaging: context.brandKit.messaging || null,\n    referenceImages: context.referenceImages,\n  }\n}\n\n/**\n * Validate decomposition event data with Zod\n */\nexport function validateDecompositionEvent(data: unknown): DecompositionEvent {\n  return DecompositionEventSchema.parse(data)\n}\n\n/**\n * Create decomposition step metadata\n */\nexport function createDecompositionStep(\n  stepName: string,\n  stepType: DecompositionStep['stepType'],\n  metadata?: Record<string, any>\n): DecompositionStep {\n  return {\n    stepName,\n    stepType,\n    status: 'pending',\n    metadata,\n    timestamp: new Date().toISOString()\n  }\n}\n\n/**\n * Update decomposition step status\n */\nexport function updateDecompositionStep(\n  step: DecompositionStep,\n  status: DecompositionStep['status'],\n  result?: any,\n  metadata?: Record<string, any>\n): DecompositionStep {\n  return {\n    ...step,\n    status,\n    result,\n    metadata: { ...step.metadata, ...metadata },\n    timestamp: new Date().toISOString()\n  }\n}\n\n/**\n * Calculate decomposition progress percentage\n */\nexport function calculateDecompositionProgress(steps: DecompositionStep[]): number {\n  if (steps.length === 0) return 0\n  \n  const completedSteps = steps.filter(step => step.status === 'completed').length\n  return Math.round((completedSteps / steps.length) * 100)\n}\n\n/**\n * Check if decomposition is complete\n */\nexport function isDecompositionComplete(steps: DecompositionStep[]): boolean {\n  return steps.length > 0 && steps.every(step => \n    step.status === 'completed' || step.status === 'failed'\n  )\n}\n\n/**\n * Get current decomposition step\n */\nexport function getCurrentDecompositionStep(steps: DecompositionStep[]): DecompositionStep | null {\n  return steps.find(step => step.status === 'running') || \n         steps.find(step => step.status === 'pending') ||\n         null\n} "],"mappings":"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","names":[]}